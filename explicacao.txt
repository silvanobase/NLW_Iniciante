Diferença entre pixel(px) e rem

Div é uma tag html que não tem significado, é apenas uma caixa usada para agrupar conteúdo.


Síncrono:
Em programação síncrona, as operações são executadas sequencialmente, uma após a outra. O programa precisa esperar que cada operação termine antes de iniciar a próxima, o que pode levar a atrasos se uma operação for demorada. 
Assíncrono:
Em programação assíncrona, as operações podem ser iniciadas e continuarem a ser executadas em segundo plano enquanto o programa realiza outras tarefas. Isso evita bloqueios e melhora a eficiência do programa, especialmente quando lidando com operações de entrada/saída (como leitura de arquivos, chamadas de rede, etc.). 
Exemplo:
Imagine fazer um pedido em um restaurante. Em programação síncrona, você esperaria o seu prato ficar pronto antes de fazer outra coisa. Em programação assíncrona, você faria o pedido e poderia fazer outras coisas, como responder e-mails, enquanto o prato é preparado. 

Para converter texto de MarkDown em HTML, utilizo a biblioteca showdown javascript

O operador lógico ||(ou), só é verdade se pelo menos uma das condições forem verdadeiras

Para enviar um novo commit para gitHub de um projeto existente:
    1 - git status
    2 - git add .
    3 - git commit -m "Criando os componentes"
    4 - git push -u origin main

{
      CSS

*{
    padding: 0;
    margin: 0;
    box-sizing: border-box;
}

body {
    background-image: url('./assets/bg.jpg');
    background-repeat: no-repeat;
    background-size: 100% auto;
    background-position: top center;
    background-color: #121214;
    color: white;
}

body *, :root {
    font-family: Inter;
    line-height: 160%;/*Distanciamento entre paragráfos*/
}

header{
    padding-top: 32px;
    text-align: center;
}

header img{
    width: 15rem;
}


main{
    max-width: 36rem;
    width: 90%;
    margin: 3rem auto;/*Automaticamente ele vai colocar no centro no left e right, e no topo e bottom 3rem*/
   
}

section {
        /*Esse 90deg quer dizer que vai começar da esquerda para direita, ou seja, a primeira cor que coloquei vai começar da esquerda e assim sucessivamente. Se eu mudar os deg, ele vai se ajeitando, por exemplo se eu colocar 0deg vai começar do bottom para cima*/
    background-image: linear-gradient(90deg, #9572FC 0%, #43E7AD 50%, #E2D45C 100%);
    border-radius: 0.625rem;
    padding-top: 4px;
}

section > div {
    /*Esse sinal quer dizer que ele vai selecionar a primeira div que encontrar na section*/
    padding: 2rem;
    padding-top: 1.5rem;
    border-radius: 0.5rem;
    background-color: #2A2634;
}

section h2 {
    letter-spacing: -0.47px;
}

section p{
    letter-spacing: -0.18px;
    color: #A1A1AA;
}

/*Animações*/

main section {
    opacity: 0;
    transform: translateY(2rem) ;
    animation-name: appear;
    animation-duration: 700ms;
    animation-fill-mode: forwards;
}

@keyframes appear {
    100% {
        opacity: 1;
        transform: translateY(0);
    }
}

form {
    display: flex;/*Faz todos elementos estarem em linha*/
    gap: 0.85rem;/*Coloca espaços entre os elementos*/
    flex-wrap: wrap;/*Faz dar uma quebra de linha sempre que um container tem conteúdo a mais*/
    margin: 1.25rem 0;
}

input, select {
    all: unset;/*Com essa linha, eu estou anulando todos estilos dos input's e select*/
    border: 2px solid #9147ff;
    border-radius: 0.5rem;
    padding: 0.675rem;
    font-size: 0.875rem;
    background-color: #00000066;
}

input{
    flex: 1;
}

button{
    width: 100%;
    border: 0;
    background-image: linear-gradient(245deg, #9572FC 0%, #43E7AD 50%, #E2D45C 100%);
    padding: 0.675rem;
    border-radius: 0.5rem;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 0.12rem;
    
    transition: all 0.3s;
}

button:hover {
    cursor: pointer;
    transform: translateY(-2px);
    box-shadow: 0 5px 1rem rgba(255, 248, 107, 0.2);
}

button:disabled {
    transition: initial;
    transform: initial;
    box-shadow: initial;
    cursor: not-allowed;
    color: black;
}

#aiResponse{
    background-color: rgb(0, 0, 0, 0.4);
    border-radius: 0.5rem;
    padding: 1.25rem;
    border-left: 4px solid #43E7AD;
}

#aiResponse ul {
    padding-left: 1.25rem;
    opacity: 0.8;
}

#aiResponse p {
    color: white;
}

.loading {
    animation: pulse 1s infinite;
}

.hidden {
    display: none;
}

 
@keyframes pulse{
    50%{
        opacity: 0.5;
    }
}

}



{
    HTML

<!DOCTYPE html>
<html lang="pt-br">

<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
        rel="stylesheet">
    <meta charset="UTF-8"><!-- Serve para configurar os caracteres, como os especiais tbm -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Serve para configurar o tamanho da viewport para se adaptar ao tamanho de cada dispositivo. Lembrando que viewport é apenas a parte branca quando começamos com um projeto -->
    <title>NLW-Agents</title>
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="./assets/logo.png" type="image/x-icon">
</head>

<body>
    <header>
        <img src="./assets/logo.png" alt="Logo nlw-agents">
    </header>

    <main>
        <section>
            <h2>Assistente de Meta</h2>
            <p>Pergunte sobre estratégias, build e dicas para seus jogos!</p>
        </section>
    </main>
</body>

</html>

}



{
    JavaScript

    const apiKeyInput = document.getElementById('apiKey')
const gameSelect = document.getElementById('gameSelect')
const questioInput = document.getElementById('questionInput')
const askButton = document.getElementById('askButton')
const aiResponse = document.getElementById('aiResponse');
const form = document.getElementById('form')

const markdownToHTML = (text) => {
    const converter = new showdown.Converter()
    return converter.makeHtml(text)
}

//Chave-api: AIzaSyAwS9i0TjEvm-S-sH_DTuojOCmp0Zj_K4w
const perguntarAI = async(question, game, apiKey) => {
    const model = "gemini-2.5-flash"
    const geminiURL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`

    const pergunta = `
        ## Especialidade
        Você é um especialista assistente de meta para o jogo ${game}

        ## Tarefa
        Você deve responder as perguntas do usuário com base no seu conhecimento do jogo, estratégias, build e dicas

        ## Regras
        - Se você não sabe a resposta, responda com 'Não sei' e não tente inventar uma resposta.
        - Se a pergunta não está relacionada ao jogo, responda com 'Essa pergunta não está relacionada ao jogo'.
        - Considere a data atual ${new Date().toLocaleDateString()}
        - Faça pesquisas atualizadas sobre o patch atual, baseado na data atual, para dar uma resposta coerente.
        - Nunca responda itens que você não tenha certeza de que existe no patch atual.

        ## Resposta
        - Economize na resposta, seja direto e responda no máximo 500 caracteres
        - Responda em markdown
        - Não precisa fazer nenhuma saudação ou despedida, apenas responda o que o usuário está querendo.
        ## Exemplo de resposta
        pergunta do usuário: Melhor build rengar jungle
        resposta: A build mais atual é:  \n\n **Itens:**\n\n coloque os itens aqui. \n\n**Runas:**\n\nexemplo de runas\n\n

        ---

        Aqui está pergunta do usuário: ${question}
    `
    const  contents = [{
        role: "user",
        parts: [{
            text: pergunta
        }]
    }]

    const tools = [{
        google_search: {}
    }]

    //Chamada api
    const response = await fetch(geminiURL, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            contents, 
            tools
        })
    })

    const data = await response.json()
    return data.candidates[0].content.parts[0].text
}

form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const key = apiKeyInput.value
    const game = gameSelect.value
    const question = questioInput.value


    if(key == '' || game == '' || question == ''){
        alert('Por favor, preencha todos os campos!')
        return
    }

    askButton.disabled = true;
    askButton.textContent = 'Perguntando...'
    askButton.classList.add('loading')


    try {
        //Perguntar a IA
       const text = await perguntarAI(question, game, key)
       aiResponse.querySelector('.response-content').innerHTML = markdownToHTML(text)
       aiResponse.classList.remove('hidden')
    } catch (error) {
        console.log('Error: ', error)
    }
    finally{
        askButton.disabled = false
        askButton.textContent = 'Perguntar'
        askButton.classList.remove('loading')
    }
})
}